<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>_decomposition &mdash; Qpca  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="_quantumUtilities" href="QUtilities.html" />
    <link rel="prev" title="QPCA" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Qpca
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">QPCA</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">_decomposition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-QPCA._decomposition">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#QPCA._decomposition.QPCA"><code class="docutils literal notranslate"><span class="pre">QPCA</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="QUtilities.html">_quantumUtilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="Q_preprocessing.html">_preprocessingUtilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="Q_postprocessing.html">_postprocessingUtilities</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Qpca</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">QPCA</a></li>
      <li class="breadcrumb-item active">_decomposition</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/QPCA.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="decomposition">
<h1>_decomposition<a class="headerlink" href="#decomposition" title="Permalink to this heading"></a></h1>
<p>This module contains an implementation of quantum PCA algorithm. This class can be used for an end-to-end process,
starting from the input matrix up to the reconstruction of the same matrix using the computed eigenvectors and eigenvalues
extracted by quantum routines.</p>
<section id="module-QPCA._decomposition">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-QPCA._decomposition" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QPCA._decomposition.</span></span><span class="sig-name descname"><span class="pre">QPCA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA" title="Permalink to this definition"></a></dt>
<dd><p>Quantum Principal component analysis (QPCA).
Implementation of the QPCA algorithm proposed in “A Low Complexity Quantum Principal Component Analysis Algorithm” paper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_matrix</strong> (<em>array-like</em>) – Input hermitian matrix on which you want to apply QPCA.</p></li>
<li><p><strong>resolution</strong> (<em>int value</em>) – Number of qubit used into the phase estimation process to encode the eigenvalues.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.input_matrix_trace">
<span class="sig-name descname"><span class="pre">input_matrix_trace</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.input_matrix_trace" title="Permalink to this definition"></a></dt>
<dd><p>The trace of the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy-like array.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.input_matrix">
<span class="sig-name descname"><span class="pre">input_matrix</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.input_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Input hermitian matrix on which you want to apply QPCA divided by its trace.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.qram_circuit">
<span class="sig-name descname"><span class="pre">qram_circuit</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.qram_circuit" title="Permalink to this definition"></a></dt>
<dd><p>The quantum circuit that encodes the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QuantumCircuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.total_circuit">
<span class="sig-name descname"><span class="pre">total_circuit</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.total_circuit" title="Permalink to this definition"></a></dt>
<dd><p>The quantum circuit that performs the encoding of the input matrix and Phase Estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QuantumCircuit.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.n_shots">
<span class="sig-name descname"><span class="pre">n_shots</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.n_shots" title="Permalink to this definition"></a></dt>
<dd><p>Number of shots for the tomography process.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.reconstructed_eigenvalue_eigenvector_tuple">
<span class="sig-name descname"><span class="pre">reconstructed_eigenvalue_eigenvector_tuple</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.reconstructed_eigenvalue_eigenvector_tuple" title="Permalink to this definition"></a></dt>
<dd><p>Array of tuples of the form [(e_1,v_1),(e_2,v_2),..] where e_s are the eigenvalues and v_s are the reconstructed eigenvectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.original_eigenValues">
<span class="sig-name descname"><span class="pre">original_eigenValues</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.original_eigenValues" title="Permalink to this definition"></a></dt>
<dd><p>Original eigenvalues of the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like,.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.original_eigenVectors">
<span class="sig-name descname"><span class="pre">original_eigenVectors</span></span><a class="headerlink" href="#QPCA._decomposition.QPCA.original_eigenVectors" title="Permalink to this definition"></a></dt>
<dd><p>Orignal eigenvectors of the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like.</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>It is important to consider that the input matrix is divided by its trace so as to have the eigenvalues between 0 and 1.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.eigenvectors_reconstruction">
<span class="sig-name descname"><span class="pre">eigenvectors_reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_repetitions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA.eigenvectors_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Method that reconstructs the eigenvalues/eigenvectors once performed Phase Estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_shots</strong> (<em>int value</em><em>, </em><em>default=50000.</em>) – Number of shots to perform in the state vector tomography function.</p></li>
<li><p><strong>n_repetitions</strong> (<em>int value</em><em>, </em><em>default=1.</em>) – Number of times that state vector tomography will be executed. If a value greater than 1 is passed, the final result will be the average result
of all the execution of the tomography.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>eigenvalue_eigenvector_tuple</strong> – List of tuples containing as first value the reconstructed eigenvalue and as second value the reconstructed eigenvector.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To classically reconstruct the eigenvectors, state vector tomography function is performed (implemented from algorithm 4.1 of “A Quantum Interior Point Method for LPs and SDPs” paper). In this
way, the statevector of the quantum state is reconstructed and a postprocessing method is executed to get the eigenvectors from the reconstructed statevector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.error_benchmarking">
<span class="sig-name descname"><span class="pre">error_benchmarking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shots_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_tomography_repetitions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA.error_benchmarking" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.generate_phase_estimation_circuit">
<span class="sig-name descname"><span class="pre">generate_phase_estimation_circuit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA.generate_phase_estimation_circuit" title="Permalink to this definition"></a></dt>
<dd><p>Generate phase estimation circuit with a number of qubits provided as resolution parameter in the constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>total_circuit_1</strong> – The quantum circuit that performs the encoding of the input matrix and Phase Estimation.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>QuantumCircuit.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.generate_qram_circuit">
<span class="sig-name descname"><span class="pre">generate_qram_circuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA.generate_qram_circuit" title="Permalink to this definition"></a></dt>
<dd><p>Generate qram circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_matrix</strong> (<em>array-like.</em>) – Input hermitian matrix that has to be encoded in quantum circuit to perform QPCA.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>qc</strong> – The quantum circuit that encodes the input matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QuantumCircuit.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method implements the quantum circuit generation to encode a generic input matrix. It is important to note the spatial complexity of the circuit that is in the order of
log2(p*q), with p number of rows and q number of columns of the input matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.quantum_input_matrix_reconstruction">
<span class="sig-name descname"><span class="pre">quantum_input_matrix_reconstruction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA.quantum_input_matrix_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Method to reconstruct the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reconstructed_input_matrix</strong> – Reconstructed input matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array-like.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Using the reconstructed eigenvectors and eigenvalues from QPCA, we can reconstruct the original input matrix using the reverse procedure of SVD.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.runtime_comparison">
<span class="sig-name descname"><span class="pre">runtime_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_n_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classical_principal_components</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rand_PCA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA.runtime_comparison" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA._decomposition.QPCA.spectral_benchmarking">
<span class="sig-name descname"><span class="pre">spectral_benchmarking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigenvector_benchmarking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalues_benchmarching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_first_eigenvectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA._decomposition.QPCA.spectral_benchmarking" title="Permalink to this definition"></a></dt>
<dd><p>Method to benchmark the reconstructed eigenvectors/eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eigenvector_benchmarking</strong> (<em>bool value</em><em>, </em><em>default=True.</em>) – If True, an eigenvectors benchmarking is performed to show how the quantum algorithm approximate the eigenvectors.</p></li>
<li><p><strong>eigenvalues_benchmarching</strong> (<em>bool value</em><em>, </em><em>default=False.</em>) – If True, an eigenvalues benchmarking is performed to show how the quantum algorithm approximate the eigenvalues.</p></li>
<li><p><strong>print_distances</strong> (<em>bool value</em><em>, </em><em>default=True.</em>) – If True, the distance (defined by the parameter distance_type) between the reconstructed and original eigenvectors is printed in the legend.</p></li>
<li><p><strong>only_first_eigenvectors</strong> (<em>bool value</em><em>, </em><em>default=True.</em>) – If True, the benchmarking is performed only for the first eigenvector. Otherwise, all the eigenvectors are considered.</p></li>
<li><p><strong>plot_delta</strong> (<em>bool value</em><em>, </em><em>default=False.</em>) – If True, a plot showing the trend of the tomography error is showed.</p></li>
<li><p><strong>distance_type</strong> (<em>string value</em><em>, </em><em>default='l2'</em>) – <p>It defines the distance measure used to benchmark the eigenvectors:</p>
<blockquote>
<div><p>-‘l2’: the l2 distance between original and reconstructed eigenvectors is computed.</p>
<p>-‘cosine’: the cosine distance between original and reconstructed eigenvectors is computed.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>save_list: array-like.</dt><dd><p>List of distances between all the original and reconsructed eigenvectors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>delta: float value.</dt><dd><p>The tomography error value.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If eigenvector_benchmarking is True</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The execution of this method shows the distance between original and reconstructed eigenvector’s values and allows to visualize the tomography error. In this way, you can check that the reconstruction of the eigenvectors always takes place with an error conforming to the one expressed in the tomography algorithm in the “A Quantum Interior Point Method for LPs and SDPs” paper.</p>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-left" title="QPCA" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="QUtilities.html" class="btn btn-neutral float-right" title="_quantumUtilities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>