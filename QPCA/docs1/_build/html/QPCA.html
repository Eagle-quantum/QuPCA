<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>decomposition &mdash; Qpca  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="quantumUtilities" href="QUtilities.html" />
    <link rel="prev" title="QPCA" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Qpca
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">QPCA</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">decomposition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-QPCA.decomposition">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#QPCA.decomposition.QPCA"><code class="docutils literal notranslate"><span class="pre">QPCA</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="QUtilities.html">quantumUtilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="Q_preprocessing.html">preprocessingUtilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="Q_postprocessing.html">postprocessingUtilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="benchmark.html">benchmark</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Example_modules.html">Example of QPCA usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_tomography_modules.html">Example of state tomography usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_benchmark.html">Example of benchmark</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Qpca</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">QPCA</a></li>
      <li class="breadcrumb-item active">decomposition</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/QPCA.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="decomposition">
<h1>decomposition<a class="headerlink" href="#decomposition" title="Permalink to this heading"></a></h1>
<p>This module contains an implementation of quantum PCA algorithm. This class can be used for an end-to-end process,
starting from the input matrix up to the reconstruction of the same matrix using the computed eigenvectors and eigenvalues
extracted by quantum routines.</p>
<section id="module-QPCA.decomposition">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-QPCA.decomposition" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QPCA.decomposition.</span></span><span class="sig-name descname"><span class="pre">QPCA</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA" title="Permalink to this definition"></a></dt>
<dd><p>Quantum Principal component analysis (QPCA).
Implementation of the QPCA algorithm proposed in “A Low Complexity Quantum Principal Component Analysis Algorithm” paper.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.input_matrix_trace">
<span class="sig-name descname"><span class="pre">input_matrix_trace</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.input_matrix_trace" title="Permalink to this definition"></a></dt>
<dd><p>The trace of the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array-like of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.input_matrix">
<span class="sig-name descname"><span class="pre">input_matrix</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.input_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Input hermitian matrix on which you want to apply QPCA divided by its trace, where <cite>n_samples</cite> is the number of samples
and <cite>n_features</cite> is the number of features. In case of non-2^N Hermitian matrix, a zero-padding method is applied to make it a 2^N matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.true_input_matrix">
<span class="sig-name descname"><span class="pre">true_input_matrix</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.true_input_matrix" title="Permalink to this definition"></a></dt>
<dd><p>This is the true input matrix that is given as input.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.resolution">
<span class="sig-name descname"><span class="pre">resolution</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.resolution" title="Permalink to this definition"></a></dt>
<dd><p>Number of qubits used for the phase estimation process to encode the eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int value</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.qram_circuit">
<span class="sig-name descname"><span class="pre">qram_circuit</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.qram_circuit" title="Permalink to this definition"></a></dt>
<dd><p>The quantum circuit that encodes the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QuantumCircuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.total_circuit">
<span class="sig-name descname"><span class="pre">total_circuit</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.total_circuit" title="Permalink to this definition"></a></dt>
<dd><p>The quantum circuit that performs the encoding of the input matrix and Phase Estimation. The number of qubits will be log(n_samples*n_features)+resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QuantumCircuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.n_shots">
<span class="sig-name descname"><span class="pre">n_shots</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.n_shots" title="Permalink to this definition"></a></dt>
<dd><p>Number of measures performed in the tomography process.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int value</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.mean_threshold">
<span class="sig-name descname"><span class="pre">mean_threshold</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.mean_threshold" title="Permalink to this definition"></a></dt>
<dd><p>This array contains the mean between the left and right peaks vertical distance to its neighbouring samples. It is used for the benchmark process to cut out the bad reconstructed eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.reconstructed_eigenvalues">
<span class="sig-name descname"><span class="pre">reconstructed_eigenvalues</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.reconstructed_eigenvalues" title="Permalink to this definition"></a></dt>
<dd><p>Reconstructed eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.reconstructed_eigenvectors">
<span class="sig-name descname"><span class="pre">reconstructed_eigenvectors</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.reconstructed_eigenvectors" title="Permalink to this definition"></a></dt>
<dd><p>Reconstructed eigenvectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>It is important to consider that the input matrix is divided by its trace so as to have the eigenvalues between 0 and 1.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.eigenvectors_reconstruction">
<span class="sig-name descname"><span class="pre">eigenvectors_reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_repetitions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.eigenvectors_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Method that reconstructs the eigenvalues/eigenvectors once performed Phase Estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_shots</strong> (<em>int value</em><em>, </em><em>default=10000</em>) – Number of measures performed in the tomography process.</p></li>
<li><p><strong>n_repetitions</strong> (<em>int value</em><em>, </em><em>default=1</em>) – Number of times that state vector tomography will be executed. If &gt; 1, the final result will be the average result
of all the execution of the tomography.</p></li>
<li><p><strong>plot_peaks</strong> (<em>bool value</em><em>, </em><em>defualt=False</em>) – If True, it returns a plot of the peaks which correspond to the eigenvalues finded by the phase estimation procedure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>reconstructed_eigenvalues</strong> (<em>array-like</em>) – Reconstructed eigenvalues.</p></li>
<li><p><strong>reconstructed_eigenvectors</strong> (<em>array-like</em>) – Reconstructed eigenvectors.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To classically reconstruct the eigenvectors, state vector tomography function is performed (implemented from algorithm 4.1 of “A Quantum Interior Point Method for LPs and SDPs” paper). In this
way, the statevector of the quantum state is reconstructed and a postprocessing method is executed to get the eigenvectors from the reconstructed statevector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimized_qram</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_qram</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_pe_circuit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit Qpca model. This method generates the encoding matrix circuit and apply the phase estimation operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_matrix</strong> (<em>array-like</em><em> of </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input hermitian matrix on which you want to apply QPCA divided by its trace, where <cite>n_samples</cite> is the number of samples
and <cite>n_features</cite> is the number of features.</p></li>
<li><p><strong>resolution</strong> (<em>int value</em>) – Number of qubits used for the phase estimation process to encode the eigenvalues.</p></li>
<li><p><strong>optimized_qram</strong> (<em>bool value</em><em>, </em><em>default=True</em>) – If True, it returns an optimized version of the preprocessing circuit. Otherwise, a custom implementation of a Qram is returned.
Unless necessary, it is recommended to keep the optimized version of this circuit.</p></li>
<li><p><strong>plot_qram</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, it returns a plot of the Qram circuit that encodes the input matrix.</p></li>
<li><p><strong>plot_pe_circuit</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, it returns a plot of the circuit composed of Qram and phase estimation operator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns the instance itself.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
<p class="rubric">Notes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction">
<span class="sig-name descname"><span class="pre">quantum_input_matrix_reconstruction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Method to reconstruct the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reconstructed_input_matrix</strong> – Reconstructed input matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array-like of shape (n_samples, n_features)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Using the reconstructed eigenvectors and eigenvalues from QPCA, we can reconstruct the original input matrix using the reverse procedure of SVD.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.spectral_benchmarking">
<span class="sig-name descname"><span class="pre">spectral_benchmarking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigenvector_benchmarking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalues_benchmarching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_benchmarking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_first_eigenvectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_with_sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hide_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.spectral_benchmarking" title="Permalink to this definition"></a></dt>
<dd><p>Method to benchmark the reconstructed eigenvectors/eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eigenvector_benchmarking</strong> (<em>bool value</em><em>, </em><em>default=True</em>) – If True, an eigenvectors benchmarking is performed to show the accuracy for the quantum algorithm in estimating the original eigenvectors.</p></li>
<li><p><strong>eigenvalues_benchmarching</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, an eigenvalues benchmarking is performed to show the accuracy for the quantum algorithm in estimating the original eigenvalues.</p></li>
<li><p><strong>sign_benchmarking</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, a table showing correct and wrong signs for each reconstructed eigenvector is returned.</p></li>
<li><p><strong>print_distances</strong> (<em>bool value</em><em>, </em><em>default=True</em>) – If True, the distance (defined by the parameter distance_type) between the reconstructed and original eigenvectors is printed in the legend.</p></li>
<li><p><strong>only_first_eigenvectors</strong> (<em>bool value</em><em>, </em><em>default=True</em>) – If True, the benchmarking is performed only for the first eigenvector. Otherwise, all the eigenvectors are considered.</p></li>
<li><p><strong>plot_delta</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, a plot showing the trend of the tomography error is showed.</p></li>
<li><p><strong>distance_type</strong> (<em>string value</em><em>, </em><em>default='l2'</em>) – <p>It defines the distance measure used to benchmark the eigenvectors:</p>
<blockquote>
<div><p>-‘l2’: the l2 distance between original and reconstructed eigenvectors is computed.</p>
<p>-‘cosine’: the cosine distance between original and reconstructed eigenvectors is computed.</p>
</div></blockquote>
</p></li>
<li><p><strong>error_with_sign</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, the eigenvectors’ benchmarking is performed considering the reconstructed sign. Otherwise, the benchmark is performed only for the absolute values of the eigenvectors (which means reconstructed eigenvectors with no
reconstructed sign). If True, it has effect only if the eigenvector_benchmarking flag is True.</p></li>
<li><p><strong>hide_plot</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, the plot for the eigenvector reconstruction benchmarking is not showed. This is useful to have a cleaner output when executing the eigenvectors reconstruction benchmarking more times (for example for different matrices).</p></li>
<li><p><strong>print_error</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, a table showing the absolute error between the original eigenvalues and the reconstructed ones is shown.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>results</strong> –</p>
<p>If eigenvector_benchmarking is True, it contains a list of two elements:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>error_list: array-like.</dt><dd><p>List of distances between the original and reconstructed eigenvectors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>delta: float value.</dt><dd><p>Tomography error value.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
<p class="rubric">Notes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.transform" title="Permalink to this definition"></a></dt>
<dd><p>Apply dimensionality reduction to input_matrix.</p>
<p>Input_matrix is projected on the first principal components previously extracted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_matrix</strong> (<em>array-like</em><em> of </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – New data, where <cite>n_samples</cite> is the number of samples
and <cite>n_features</cite> is the number of features.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>input_matrix_transformed</strong> – Projection of input_matrix in the first principal components, where <cite>n_samples</cite>
is the number of samples and <cite>n_components</cite> is the number of the components.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_components)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>