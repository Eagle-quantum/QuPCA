<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>decomposition &mdash; Qpca  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="quantumUtilities" href="QUtilities.html" />
    <link rel="prev" title="QPCA" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Qpca
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">QPCA</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">decomposition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-QPCA.decomposition">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#QPCA.decomposition.QPCA"><code class="docutils literal notranslate"><span class="pre">QPCA</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="QUtilities.html">quantumUtilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="QUtilities.html#module-QPCA.quantumUtilities">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="QUtilities.html#QPCA.quantumUtilities.from_binary_tree_to_qcircuit"><code class="docutils literal notranslate"><span class="pre">from_binary_tree_to_qcircuit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="QUtilities.html#QPCA.quantumUtilities.state_vector_tomography"><code class="docutils literal notranslate"><span class="pre">state_vector_tomography()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="QUtilities.html#QPCA.quantumUtilities.thetas_computation"><code class="docutils literal notranslate"><span class="pre">thetas_computation()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Q_preprocessing.html">preprocessingUtilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Q_preprocessing.html#module-QPCA.preprocessingUtilities">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Q_preprocessing.html#QPCA.preprocessingUtilities.generate_matrix"><code class="docutils literal notranslate"><span class="pre">generate_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Q_postprocessing.html">postprocessingUtilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Q_postprocessing.html#module-QPCA.postprocessingUtilities">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="Q_postprocessing.html#QPCA.postprocessingUtilities.general_postprocessing"><code class="docutils literal notranslate"><span class="pre">general_postprocessing()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="benchmark.html">benchmark</a><ul>
<li class="toctree-l3"><a class="reference internal" href="benchmark.html#module-QPCA.benchmark">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="benchmark.html#QPCA.benchmark.eigenvalues_benchmarking"><code class="docutils literal notranslate"><span class="pre">eigenvalues_benchmarking()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="benchmark.html#QPCA.benchmark.eigenvectors_benchmarking"><code class="docutils literal notranslate"><span class="pre">eigenvectors_benchmarking()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="benchmark.html#QPCA.benchmark.error_benchmark"><code class="docutils literal notranslate"><span class="pre">error_benchmark()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="benchmark.html#QPCA.benchmark.sign_reconstruction_benchmarking"><code class="docutils literal notranslate"><span class="pre">sign_reconstruction_benchmarking()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Example_modules.html">Example of QPCA usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Example%20of%20QPCA%20usage.html">Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Example_tomography_modules.html">Example of state tomography usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Example%20of%20state%20tomography%20usage.html">Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Example_benchmark.html">Example of benchmark</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Example%20of%20benchmark.html">Example</a><ul>
<li class="toctree-l3"><a class="reference internal" href="Example%20of%20benchmark.html#eigenvectors-benchmark">Eigenvectors benchmark</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example%20of%20benchmark.html#eigenvalues-benchmark">Eigenvalues benchmark</a></li>
<li class="toctree-l3"><a class="reference internal" href="Example%20of%20benchmark.html#eigenvectors-reconstruction-error-benchmark">Eigenvectors reconstruction error benchmark</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Qpca</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">QPCA</a></li>
      <li class="breadcrumb-item active">decomposition</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/QPCA.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="decomposition">
<h1>decomposition<a class="headerlink" href="#decomposition" title="Permalink to this heading"></a></h1>
<p>This module contains an implementation of quantum PCA algorithm. This class can be used for an end-to-end process,
starting from the input matrix up to the reconstruction of the same matrix using the computed eigenvectors and eigenvalues
extracted by quantum routines.</p>
<section id="module-QPCA.decomposition">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-QPCA.decomposition" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">QPCA.decomposition.</span></span><span class="sig-name descname"><span class="pre">QPCA</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA" title="Permalink to this definition"></a></dt>
<dd><p>Quantum Principal component analysis (QPCA).
Implementation of the QPCA algorithm proposed in “A Low Complexity Quantum Principal Component Analysis Algorithm” paper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_matrix</strong> (<em>array-like</em><em> of </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input hermitian matrix on which you want to apply QPCA, where <cite>n_samples</cite> is the number of samples
and <cite>n_features</cite> is the number of features.</p></li>
<li><p><strong>resolution</strong> (<em>int value</em>) – Number of qubits used for the phase estimation process to encode the eigenvalues.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.input_matrix_trace">
<span class="sig-name descname"><span class="pre">input_matrix_trace</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.input_matrix_trace" title="Permalink to this definition"></a></dt>
<dd><p>The trace of the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NumPy array-like of shape (n_features,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.input_matrix">
<span class="sig-name descname"><span class="pre">input_matrix</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.input_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Input hermitian matrix on which you want to apply QPCA divided by its trace, where <cite>n_samples</cite> is the number of samples
and <cite>n_features</cite> is the number of features.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like of shape (n_samples, n_features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.qram_circuit">
<span class="sig-name descname"><span class="pre">qram_circuit</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.qram_circuit" title="Permalink to this definition"></a></dt>
<dd><p>The quantum circuit that encodes the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QuantumCircuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.total_circuit">
<span class="sig-name descname"><span class="pre">total_circuit</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.total_circuit" title="Permalink to this definition"></a></dt>
<dd><p>The quantum circuit that performs the encoding of the input matrix and Phase Estimation. The number of qubits will be log(n_samples*n_features)+resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QuantumCircuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.n_shots">
<span class="sig-name descname"><span class="pre">n_shots</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.n_shots" title="Permalink to this definition"></a></dt>
<dd><p>Number of measures performed in the tomography process.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int value</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.reconstructed_eigenvalue_eigenvector_tuple">
<span class="sig-name descname"><span class="pre">reconstructed_eigenvalue_eigenvector_tuple</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.reconstructed_eigenvalue_eigenvector_tuple" title="Permalink to this definition"></a></dt>
<dd><p>Array of tuples of the form [(e_1,v_1),(e_2,v_2),..] where e_s are the eigenvalues and v_s are the reconstructed eigenvectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.original_eigenValues">
<span class="sig-name descname"><span class="pre">original_eigenValues</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.original_eigenValues" title="Permalink to this definition"></a></dt>
<dd><p>Original eigenvalues of the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.original_eigenVectors">
<span class="sig-name descname"><span class="pre">original_eigenVectors</span></span><a class="headerlink" href="#QPCA.decomposition.QPCA.original_eigenVectors" title="Permalink to this definition"></a></dt>
<dd><p>Orignal eigenvectors of the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>It is important to consider that the input matrix is divided by its trace so as to have the eigenvalues between 0 and 1.</p>
<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.eigenvectors_reconstruction">
<span class="sig-name descname"><span class="pre">eigenvectors_reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_repetitions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.eigenvectors_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Method that reconstructs the eigenvalues/eigenvectors once performed Phase Estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_shots</strong> (<em>int value</em><em>, </em><em>default=50000.</em>) – Number of measures performed in the tomography process.</p></li>
<li><p><strong>n_repetitions</strong> (<em>int value</em><em>, </em><em>default=1.</em>) – Number of times that state vector tomography will be executed. If &gt; 1, the final result will be the average result
of all the execution of the tomography.</p></li>
<li><p><strong>plot_peaks</strong> (<em>bool value</em><em>, </em><em>defualt=False</em>) – If True, it returns a plot of the peaks which correspond to the eigenvalues finded by the phase estimation procedure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>eigenvalue_eigenvector_tuple</strong> – List of tuples containing as first value the reconstructed eigenvalue and as second value the reconstructed eigenvector.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array-like.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To classically reconstruct the eigenvectors, state vector tomography function is performed (implemented from algorithm 4.1 of “A Quantum Interior Point Method for LPs and SDPs” paper). In this
way, the statevector of the quantum state is reconstructed and a postprocessing method is executed to get the eigenvectors from the reconstructed statevector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.error_benchmarking">
<span class="sig-name descname"><span class="pre">error_benchmarking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shots_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.error_benchmarking" title="Permalink to this definition"></a></dt>
<dd><p>Method to benchmark the error of the reconstructed eigenvectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shots_dict</strong> (<em>dict-like</em>) – Dictionary that contains the number of shots executed for each reconstructed eigenvalues for a specific resolution value.</p></li>
<li><p><strong>errors_dict</strong> (<em>dict-like</em>) – Dictionary where a specific value of the resolution used in the phase estimation (key) is associated with a list of tuples where each tuple contains the specific reconstructed eigenvalue with all the error of the related reconstructed eigenvector (for each number of shots).</p></li>
<li><p><strong>delta_list</strong> (<em>array-like</em>) – List of all the delta (tomography) error for each number of shots executed in the experiments.</p></li>
<li><p><strong>plot_delta</strong> (<em>bool value</em><em>, </em><em>default=False.</em>) – If True, a plot showing the trend of the tomography error is showed.</p></li>
<li><p><strong>distance_type</strong> (<em>string value</em><em>, </em><em>default='l2'</em>) – <p>It defines the distance measure used to benchmark the eigenvectors:</p>
<blockquote>
<div><p>-‘l2’: the l2 distance between original and reconstructed eigenvectors is computed.</p>
<p>-‘cosine’: the cosine distance between original and reconstructed eigenvectors is computed.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method should be executed after the execution of eigenvectors_benchmarking() method in the spectral_benchmarking, just to visualize better in specific plots the trends of the reconstruction error for each reconstructed eigenvectors. More precisely, it should be executed after executing eigenvectors_benchmarking method for a different number of shots such that you can visualize better the error trend. You can also use this method to visualize the trends of the reconstruction error for a different number of shots at the increasing of the number of resolution qubits. The important thing to take into consideration is that you need to pass as argument the two dictionary described in the documentation (see the benchmark notebook for a more practical example)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_qram</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_pe_circuit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fit Qpca model. This method generates the encoding matrix circuit and apply the phase estimation operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_matrix</strong> (<em>array-like</em><em> of </em><em>shape</em><em> (</em><em>n_samples</em><em>, </em><em>n_features</em><em>)</em>) – Input hermitian matrix on which you want to apply QPCA divided by its trace, where <cite>n_samples</cite> is the number of samples
and <cite>n_features</cite> is the number of features.</p></li>
<li><p><strong>resolution</strong> (<em>int value</em>) – Number of qubits used for the phase estimation process to encode the eigenvalues.</p></li>
<li><p><strong>plot_qram</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, it returns a plot of the Qram circuit that encodes the input matrix.</p></li>
<li><p><strong>plot_pe_circuit</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, it returns a plot of the circuit composed of Qram and phase estimation operator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – Returns the instance itself.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
<p class="rubric">Notes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction">
<span class="sig-name descname"><span class="pre">quantum_input_matrix_reconstruction</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction" title="Permalink to this definition"></a></dt>
<dd><p>Method to reconstruct the input matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>reconstructed_input_matrix</strong> – Reconstructed input matrix.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array-like of shape (n_samples, n_features)</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Using the reconstructed eigenvectors and eigenvalues from QPCA, we can reconstruct the original input matrix using the reverse procedure of SVD.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="QPCA.decomposition.QPCA.spectral_benchmarking">
<span class="sig-name descname"><span class="pre">spectral_benchmarking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigenvector_benchmarking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalues_benchmarching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sign_benchmarking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_first_eigenvectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_with_sign</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hide_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">print_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QPCA.decomposition.QPCA.spectral_benchmarking" title="Permalink to this definition"></a></dt>
<dd><p>Method to benchmark the reconstructed eigenvectors/eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eigenvector_benchmarking</strong> (<em>bool value</em><em>, </em><em>default=True</em>) – If True, an eigenvectors benchmarking is performed to show the accuracy for the quantum algorithm in estimating the original eigenvectors.</p></li>
<li><p><strong>eigenvalues_benchmarching</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, an eigenvalues benchmarking is performed to show the accuracy for the quantum algorithm in estimating the original eigenvalues.</p></li>
<li><p><strong>sign_benchmarking</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, a table showing correct and wrong signs for each reconstructed eigenvector is returned.</p></li>
<li><p><strong>print_distances</strong> (<em>bool value</em><em>, </em><em>default=True</em>) – If True, the distance (defined by the parameter distance_type) between the reconstructed and original eigenvectors is printed in the legend.</p></li>
<li><p><strong>only_first_eigenvectors</strong> (<em>bool value</em><em>, </em><em>default=True</em>) – If True, the benchmarking is performed only for the first eigenvector. Otherwise, all the eigenvectors are considered.</p></li>
<li><p><strong>plot_delta</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, a plot showing the trend of the tomography error is showed.</p></li>
<li><p><strong>distance_type</strong> (<em>string value</em><em>, </em><em>default='l2'</em>) – <p>It defines the distance measure used to benchmark the eigenvectors:</p>
<blockquote>
<div><p>-‘l2’: the l2 distance between original and reconstructed eigenvectors is computed.</p>
<p>-‘cosine’: the cosine distance between original and reconstructed eigenvectors is computed.</p>
</div></blockquote>
</p></li>
<li><p><strong>error_with_sign</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, the eigenvectors’ benchmarking is performed considering the reconstructed sign. Otherwise, the benchmark is performed only for the absolute values of the eigenvectors (which means reconstructed eigenvectors with no
reconstructed sign). If True, it has effect only if the eigenvector_benchmarking flag is True.</p></li>
<li><p><strong>hide_plot</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, the plot for the eigenvector reconstruction benchmarking is not showed. This is useful to have a cleaner output when executing the eigenvectors reconstruction benchmarking more times (for example for different matrices).</p></li>
<li><p><strong>print_error</strong> (<em>bool value</em><em>, </em><em>default=False</em>) – If True, a table showing the absolute error between the original eigenvalues and the reconstructed ones is shown.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>save_list: array-like.</dt><dd><p>List of distances between all the original and reconsructed eigenvectors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>delta: float value.</dt><dd><p>The tomography error value.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If eigenvector_benchmarking is True</p>
</dd>
</dl>
<p class="rubric">Notes</p>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>