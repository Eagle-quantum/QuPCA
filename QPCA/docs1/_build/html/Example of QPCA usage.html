<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Example &mdash; Qpca  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Example of state tomography usage" href="Example_tomography_modules.html" />
    <link rel="prev" title="Example of QPCA usage" href="Example_modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Qpca
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="modules.html">QPCA</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Example_modules.html">Example of QPCA usage</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Example_tomography_modules.html">Example of state tomography usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Example_benchmark.html">Example of benchmark</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Qpca</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="Example_modules.html">Example of QPCA usage</a></li>
      <li class="breadcrumb-item active">Example</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Example of QPCA usage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="example">
<h1>Example<a class="headerlink" href="#example" title="Permalink to this heading">ÔÉÅ</a></h1>
<p>First, you have to import the necessary modules from the package and then you can generate a random Hermitian
matrix using <a class="reference internal" href="Q_preprocessing.html#QPCA.preprocessingUtilities.generate_matrix" title="QPCA.preprocessingUtilities.generate_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_matrix()</span></code></a> method provided in the package. You can
set the matrix dimension and a seed for the reproducibility of the execution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
 <span class="o">*</span>
 <span class="o">*/</span>
  <span class="kn">from</span> <span class="nn">QPCA.decomposition.Qpca</span> <span class="kn">import</span> <span class="n">QPCA</span>
  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="kn">import</span> <span class="nn">random</span>
  <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
  <span class="kn">from</span> <span class="nn">QPCA.preprocessingUtilities.preprocessing_matrix_utilities</span> <span class="kn">import</span> <span class="n">generate_matrix</span>

  <span class="n">matrix_dimension</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">seed</span><span class="o">=</span><span class="mi">19</span>
  <span class="n">input_matrix</span><span class="o">=</span><span class="n">generate_matrix</span><span class="p">(</span><span class="n">matrix_dimension</span><span class="o">=</span><span class="n">matrix_dimension</span><span class="p">,</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">input_matrix</span><span class="p">)</span>

<span class="go">[[0.59 0.13]</span>
<span class="go">[0.13 0.08]]</span>

<span class="go">eigenvalue: 0.04912229458049476 - eigenvector: [-0.233  0.973]</span>
<span class="go">eigenvalue: 0.6199503657038241 - eigenvector: [0.973 0.233]</span>
</pre></div>
</div>
<p>Once you have your input matrix, you can fit your QPCA model, specifying the number of resolution qubit
that you need for the phase estimation process. Remember that a higher resolution generally means better
accuracy results but lower performance.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">resolution</span><span class="o">=</span><span class="mi">8</span>
<span class="n">qpca</span><span class="o">=</span><span class="n">QPCA</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">input_matrix</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span><span class="n">plot_qram</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">plot_pe_circuit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">qpca</span><span class="o">.</span><span class="n">input_matrix</span><span class="p">))</span>

<span class="go">(array([0.92658152, 0.07341848]),</span>
<span class="go">array([[ 0.9725247 , -0.23279972],</span>
<span class="go">       [ 0.23279972,  0.9725247 ]]))</span>
</pre></div>
</div>
<p>If you set the boolean flag plot_qram and plot_pe_circuit to True as in the example before, you are able to see
two plots like the ones below.</p>
<p>Specifically, this plot shows the circuit that implements the encoding of the input matrix in the quantum registers.
As you can see, the number of qubit required to store the matrix is in the order of log(n*m), where n and m
are the number of rows and columns of the input matrix.</p>
<img alt="_images/qram.png" src="_images/qram.png" />
<p>The other plot shows the general circuit made of the encoding part plus the phase estimation operator.
Notice that the number of qubits used for the phase estimation in this case are 9: 8 specified by the resolution
parameter to encode the eigenvalues and 1 to encode the eigenvectors. In general, you will have the qubits specified
in the resolution parameter plus half of the qubits used for the matrix encoding.</p>
<img alt="_images/pe.png" src="_images/pe.png" />
<p>The core part of this library is the eigenvector reconstruction that you can perform using <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.eigenvectors_reconstruction" title="QPCA.decomposition.QPCA.eigenvectors_reconstruction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_reconstruction()</span></code></a>. You can
specify, as input parameters, <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.n_shots" title="QPCA.decomposition.QPCA.n_shots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_shots</span></code></a> which is the number of measure that you
want to perform in the state vector tomography, <code class="xref py py-obj docutils literal notranslate"><span class="pre">n_repetitions</span></code> which is the
number of times that you want to repeat the tomography process, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_peaks</span></code>
if you want to plot the output of the phase estimation which represent the most valuable approximated eigenvalues.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eig</span><span class="o">=</span><span class="n">qpca</span><span class="o">.</span><span class="n">eigenvectors_reconstruction</span><span class="p">(</span><span class="n">n_shots</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span><span class="n">n_repetitions</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">plot_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eig</span><span class="p">)</span>

<span class="go">[(0.92578125, array([0.97252803, 0.23287312])),</span>
<span class="go">(0.07421875, array([-0.23333264,  0.97138455]))]</span>
</pre></div>
</div>
<p>With the boolean flag <code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_peaks</span></code> set to True, you can visualize a plot like the
one below, where you can see the peaks that represent the eigenvalues that phase estimation approximates with high probability.
As you can see, here the two peaks are 0.92 and 0.07 which are the two eigenvalues that you are able to
estimate with the resolution and the number of shots that you provide.</p>
<img alt="_images/peaks.png" src="_images/peaks.png" />
<p>Finally, you can reconstruct the original input matrix using <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction" title="QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantum_input_matrix_reconstruction()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rec_input_matrix</span><span class="o">=</span><span class="n">qpca</span><span class="o">.</span><span class="n">quantum_input_matrix_reconstruction</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rec_input_matrix</span><span class="p">)</span>

<span class="go">array([[0.5892648 , 0.12654384],</span>
<span class="go">       [0.12654384, 0.07984454]])</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>