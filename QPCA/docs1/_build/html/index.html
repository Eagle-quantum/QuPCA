<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to Qpca’s documentation! &mdash; Qpca  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="QPCA" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            Qpca
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">QPCA</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Qpca</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Welcome to Qpca’s documentation!</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="welcome-to-qpca-s-documentation">
<h1>Welcome to Qpca’s documentation!<a class="headerlink" href="#welcome-to-qpca-s-documentation" title="Permalink to this heading"></a></h1>
<p>This is the documentation of the Qpca package implemented using Qiskit SDK. In the <a class="reference internal" href="QPCA.html#module-QPCA.decomposition" title="QPCA.decomposition"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decomposition</span></code></a> module, you
will find the <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA" title="QPCA.decomposition.QPCA"><code class="xref py py-class docutils literal notranslate"><span class="pre">QPCA</span></code></a> Qpca class implementation. One of the main method is <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.fit" title="QPCA.decomposition.QPCA.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> to fit the Qpca model.
In this context, fitting the model means building the circuit which encode an arbitrary input matrix that you provide as input and to perform phase estimation to encode the eigenvalues of the input matrix in
the quantum registers.
With <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.eigenvectors_reconstruction" title="QPCA.decomposition.QPCA.eigenvectors_reconstruction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_reconstruction()</span></code></a> method you can reconstruct the original eigenvectors (and eigenvalues)
by exploiting the <a class="reference internal" href="QUtilities.html#QPCA.quantumUtilities.state_vector_tomography" title="QPCA.quantumUtilities.state_vector_tomography"><code class="xref py py-meth docutils literal notranslate"><span class="pre">state_vector_tomography()</span></code></a> method
which implements state vector tomography algorithm. Finally, once you have reconstructed the eigenvectors and eigenvalues,
you can also reconstruct the original input matrix using <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction" title="QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantum_input_matrix_reconstruction()</span></code></a>
to assess the accuracy of the execution quantum algorithm. If the output is not satisfying, you can think to
increase the number of shots or the number of qubits for the phase estimation resolution.</p>
<p><strong>Example of Qpca usage.</strong></p>
<p>First, you have to import the necessary modules from the package and then you can generate a random Hermitian
matrix using <a class="reference internal" href="Q_preprocessing.html#QPCA.preprocessingUtilities.generate_matrix" title="QPCA.preprocessingUtilities.generate_matrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_matrix()</span></code></a> method provided in the package. You can
set the matrix dimension and a seed for the reproducibility of the execution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
 <span class="o">*</span>
 <span class="o">*/</span>
  <span class="kn">from</span> <span class="nn">QPCA.decomposition.Qpca</span> <span class="kn">import</span> <span class="n">QPCA</span>
  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="kn">import</span> <span class="nn">random</span>
  <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
  <span class="kn">from</span> <span class="nn">QPCA.preprocessingUtilities.preprocessing_matrix_utilities</span> <span class="kn">import</span> <span class="n">generate_matrix</span>

  <span class="n">matrix_dimension</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">seed</span><span class="o">=</span><span class="mi">19</span>
  <span class="n">input_matrix</span><span class="o">=</span><span class="n">generate_matrix</span><span class="p">(</span><span class="n">matrix_dimension</span><span class="o">=</span><span class="n">matrix_dimension</span><span class="p">,</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">input_matrix</span><span class="p">)</span>
<span class="o">======================</span>
<span class="p">[[</span><span class="mf">0.59</span> <span class="mf">0.13</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.13</span> <span class="mf">0.08</span><span class="p">]]</span>

<span class="n">eigenvalue</span><span class="p">:</span> <span class="mf">0.04912229458049476</span> <span class="o">-</span> <span class="n">eigenvector</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.233</span>  <span class="mf">0.973</span><span class="p">]</span>
<span class="n">eigenvalue</span><span class="p">:</span> <span class="mf">0.6199503657038241</span> <span class="o">-</span> <span class="n">eigenvector</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.973</span> <span class="mf">0.233</span><span class="p">]</span>
</pre></div>
</div>
<p>Once you have your input matrix, you can fit your QPCA model, specifying the number of resolution qubit
that you need for the phase estimation process. Remember that a higher resolution generally means better
accuracy results but lower performance.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">resolution</span><span class="o">=</span><span class="mi">8</span>
<span class="n">qpca</span><span class="o">=</span><span class="n">QPCA</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">input_matrix</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span><span class="n">plot_qram</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">plot_pe_circuit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">qpca</span><span class="o">.</span><span class="n">input_matrix</span><span class="p">))</span>
<span class="o">======================</span>
<span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="mf">0.92658152</span><span class="p">,</span> <span class="mf">0.07341848</span><span class="p">]),</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">0.9725247</span> <span class="p">,</span> <span class="o">-</span><span class="mf">0.23279972</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.23279972</span><span class="p">,</span>  <span class="mf">0.9725247</span> <span class="p">]]))</span>
</pre></div>
</div>
<p>If you set the boolean flag plot_qram and plot_pe_circuit to True as in the example before, you are able to see
two plots like the ones below.</p>
<p>Specifically, this plot shows the circuit that implements the encoding of the input matrix in the quantum registers.
As you can see, the number of qubit required to store the matrix is in the order of log(n*m), where n and m
are the number of rows and columns of the input matrix.</p>
<img alt="_images/qram.png" src="_images/qram.png" />
<p>The other plot shows the general circuit made of the encoding part plus the phase estimation operator.
Notice that the number of qubits used for the phase estimation in this case are 9: 8 specified by the resolution
parameter to encode the eigenvalues and 1 to encode the eigenvectors. In general, you will have the qubits specified
in the resolution parameter plus half of the qubits used for the matrix encoding.</p>
<img alt="_images/pe.png" src="_images/pe.png" />
<p>The core part of this library is the eigenvector reconstruction that you can perform using <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.eigenvectors_reconstruction" title="QPCA.decomposition.QPCA.eigenvectors_reconstruction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors_reconstruction()</span></code></a>. You can
specify, as input parameters, <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.n_shots" title="QPCA.decomposition.QPCA.n_shots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_shots</span></code></a> which is the number of measure that you
want to perform in the state vector tomography, <code class="xref py py-obj docutils literal notranslate"><span class="pre">n_repetitions</span></code> which is the
number of times that you want to repeat the tomography process, and <code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_peaks</span></code>
if you want to plot the output of the phase estimation which represent the most valuable approximated eigenvalues.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eig</span><span class="o">=</span><span class="n">qpca</span><span class="o">.</span><span class="n">eigenvectors_reconstruction</span><span class="p">(</span><span class="n">n_shots</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span><span class="n">n_repetitions</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">plot_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">eig</span><span class="p">)</span>
<span class="o">======================</span>
<span class="p">[(</span><span class="mf">0.92578125</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="mf">0.97252803</span><span class="p">,</span> <span class="mf">0.23287312</span><span class="p">])),</span>
<span class="p">(</span><span class="mf">0.07421875</span><span class="p">,</span> <span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.23333264</span><span class="p">,</span>  <span class="mf">0.97138455</span><span class="p">]))]</span>
</pre></div>
</div>
<p>With the boolean flag <code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_peaks</span></code> set to True, you can visualize a plot like the
one below, where you can see the peaks that represent the eigenvalues that phase estimation approximates with high probability.
As you can see, here the two peaks are 0.92 and 0.07 which are the two eigenvalues that you are able to
estimate with the resolution and the number of shots that you provide.</p>
<img alt="_images/peaks.png" src="_images/peaks.png" />
<p>Finally, you can reconstruct the original input matrix using <a class="reference internal" href="QPCA.html#QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction" title="QPCA.decomposition.QPCA.quantum_input_matrix_reconstruction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantum_input_matrix_reconstruction()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rec_input_matrix</span><span class="o">=</span><span class="n">qpca</span><span class="o">.</span><span class="n">quantum_input_matrix_reconstruction</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">rec_input_matrix</span><span class="p">)</span>
<span class="o">======================</span>
<span class="n">array</span><span class="p">([[</span><span class="mf">0.5892648</span> <span class="p">,</span> <span class="mf">0.12654384</span><span class="p">],</span>
<span class="p">[</span><span class="mf">0.12654384</span><span class="p">,</span> <span class="mf">0.07984454</span><span class="p">]])</span>
</pre></div>
</div>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">QPCA</a><ul>
<li class="toctree-l2"><a class="reference internal" href="QPCA.html">decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="QUtilities.html">quantumUtilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="Q_preprocessing.html">preprocessingUtilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="Q_postprocessing.html">postprocessingUtilities</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-right" title="QPCA" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Tommaso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>